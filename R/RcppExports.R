# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

factorial_f <- function(k) {
    .Call('rfda_factorial_f', PACKAGE = 'rfda', k)
}

quantileCpp <- function(x, probs) {
    .Call('rfda_quantileCpp', PACKAGE = 'rfda', x, probs)
}

trapz_cpp <- function(x, y) {
    .Call('rfda_trapz_cpp', PACKAGE = 'rfda', x, y)
}

#' Correlation Generation Function
#'
#' This function performs the generation of correlation sequence.
#'
#' The Matern correlation is \deqn{rho1 = 2 * sqrt(n) * rho / rho0} and
#' \deqn{r = rho1 ^ nu * besselK(nu, rho1) / gamma(nu) / 2 ^ (nu - 1)}
#' As nu goes to infinity, the correlation converges to \deqn{exp(-(rho/rho0)^2)}.
#'
#' @param x A numerical vector.
#' @param corrType A string, the type of correlation function, "BesselJ", "Matern" or "rq".
#'   Please see "Details" for more details.
#' @param x0 A numeric, the shape of correlation. It must be greater than zero. Default value is 1.
#' @param nu A numeric, it is only used when corrType is 'Matern'. It must be greater than zero.
#'   Default value is 2.5. Please see "Details" for more details.
#' @return A correlation sequence.
#' @examples
#' require(ggplot2)
#' x <- seq(-10, 10, len = 101)
#' ggplot(data.frame(x, y = corrGen(x, "BesselJ")), aes(x, y, colour = "BesselJ")) +
#'   geom_line(size = 1.2) + geom_line(aes(x, y, colour = "Matern (nu=2.5)"),
#'   data.frame(x, y = corrGen(x, "Matern")), size = 1.2) +
#'   geom_line(aes(x, y, colour = "rq"), data.frame(x, y = corrGen(x, "rq")), size = 1.2) +
#'   labs(title = "Three types of correlation sequences", colour = "Correlation Type",
#'        x = "Distance", y = "Correlation Strength")
#' @export
corrGen <- function(x, corrType, x0 = 1.0, nu = 2.5) {
    .Call('rfda_corrGen', PACKAGE = 'rfda', x, corrType, x0, nu)
}

#' Correlation Generation Function
#'
#' This function performs the generation of correlation sequence.
#'
#' The Matern correlation is \deqn{rho1 = 2 * sqrt(n) * rho / rho0} and
#' \deqn{r = rho1 ^ nu * besselK(nu, rho1) / gamma(nu) / 2 ^ (nu - 1)}
#' As nu goes to infinity, the correlation converges to \deqn{exp(-(rho/rho0)^2)}.
#'
#' @param n An integer, the number of sample size.
#' @param timePnt A numeric vector, the observed time.
#' @param meanFunc,varFunc The function to generate mean function and variance function.
#' @param measErrVar The variance of measurement error.
#' @param corrType,x0,nu The parameters to generate correlation sequence.
#' @return A data.frame containing sample id, observed time and corresponding observed values.
#' @examples
#' require(ggplot2)
#' tp <- seq(1, 10, len = 7)
#' DT <- funcDataGen(6, tp, function(x) sin(x), function(x) rep(1, length(x)), "BesselJ")
#' ggplot(DT, aes(x = t, y = y, color = factor(sampleID))) + geom_line() + labs(color = "Sample ID")
#'
#' DT2 <- funcDataGen(6, tp, function(x) sin(x), function(x) cos(x)/2 + 2, "BesselJ")
#' ggplot(DT2, aes(x = t, y = y, color = factor(sampleID))) + geom_line() + labs(color = "Sample ID")
#' @export
funcDataGen <- function(n, timePnt, meanFunc, varFunc, corrType, measErrVar = 1, x0 = 1.0, nu = 2.5) {
    .Call('rfda_funcDataGen', PACKAGE = 'rfda', n, timePnt, meanFunc, varFunc, corrType, measErrVar, x0, nu)
}

getEigRes <- function(CFMat2, variable, workTimePnts, meanFuncsWork, allTimePnts) {
    .Call('rfda_getEigRes', PACKAGE = 'rfda', CFMat2, variable, workTimePnts, meanFuncsWork, allTimePnts)
}

getFpcScoresIN <- function(allTimePnts, splitVar, yMat, eigFuncs, shrink, eigVals, measErrVar) {
    .Call('rfda_getFpcScoresIN', PACKAGE = 'rfda', allTimePnts, splitVar, yMat, eigFuncs, shrink, eigVals, measErrVar)
}

getFpcScoresReg <- function(allTimePnts, splitVar, yMat, eigFuncs, eigVals, measErrVar, methodFPCS) {
    .Call('rfda_getFpcScoresReg', PACKAGE = 'rfda', allTimePnts, splitVar, yMat, eigFuncs, eigVals, measErrVar, methodFPCS)
}

getFpcScoresSparse <- function(splitVar, yList, timeIdx, subId, eigFuncs, eigVals, measErrVar, methodFPCS, getMse) {
    .Call('rfda_getFpcScoresSparse', PACKAGE = 'rfda', splitVar, yList, timeIdx, subId, eigFuncs, eigVals, measErrVar, methodFPCS, getMse)
}

getRhoReg <- function(rhoFactor, allTimePnts, splitVar, yMat, eigFuncs, eigVals, measErrVar, methodFPCS, rho, minMearErr) {
    .Call('rfda_getRhoReg', PACKAGE = 'rfda', rhoFactor, allTimePnts, splitVar, yMat, eigFuncs, eigVals, measErrVar, methodFPCS, rho, minMearErr)
}

getRhoSparse <- function(rhoFactor, splitVar, yList, timeIdx, subId, eigFuncs, eigVals, measErrVar, methodFPCS, rho) {
    .Call('rfda_getRhoSparse', PACKAGE = 'rfda', rhoFactor, splitVar, yList, timeIdx, subId, eigFuncs, eigVals, measErrVar, methodFPCS, rho)
}

spline_cpp <- function(x, y, xi) {
    .Call('rfda_spline_cpp', PACKAGE = 'rfda', x, y, xi)
}

interp1_cpp <- function(x, y, xi, method) {
    .Call('rfda_interp1_cpp', PACKAGE = 'rfda', x, y, xi, method)
}

#' 2-D data interpolation.
#'
#' Returns interpolated values of a 2-D function at specific query points using
#' linear interpolation. The extrapolation is used, please be caution in using the
#' values which \code{xi} is larger than \code{max(x)/max(y)} and smaller than \code{min(x)/min(y)}.
#'
#' @param x A vector with n1 elements, \code{x[i]} is a support, \code{i = 1, ..., n1}.
#'   If \code{x} is not sorted, it will be sorted. If \code{x} is not unique, the corresponding \code{v} values
#'   will be averaged.
#' @param y A vector with n2 elements, \code{y[j]} is a support, \code{j = 1, ..., n2}.
#'   If \code{y} is not sorted, it will be sorted. If \code{y} is not unique, the corresponding \code{v} values
#'   will be averaged.
#' @param v A matrix with size n1 by n2, \code{v[i, j]} is the corresponding value at grid \code{(x[i], y[j])}.
#' @param xi A vector with m elements, \code{xi[k]} is the point which you want to interpolate,
#'   \code{k = 1, ..., m1}.
#' @param yi A vector with m elements, \code{yi[l]} is the point which you want to interpolate,
#'   \code{l = 1, ..., m2}.
#' @param method A string "linear" or "spline", the method of interpolation.
#' @return A matrix with the interpolated values corresponding to \code{xi} and \code{yi}.
#' @section Reference:
#' Cleve Moler, Numerical Computing with MATLAB, chapter 3,
#'   \url{http://www.mathworks.com/moler/index_ncm.html}. \cr
#' Kai Habel, Jaroslav Hajek, interp2, Octave.
#' @examples
#' # example in MatLab
#' library(lattice)
#' # data generation
#' x <- seq(-3, 3, 1)
#' xm <- expand.grid(x, x)
#' z <- 3*(1-xm[,1])^2.*exp(-(xm[,1]^2) - (xm[,2]+1)^2) -
#'   10*(xm[,1]/5 - xm[,1]^3 - xm[,2]^5)*exp(-xm[,1]^2-xm[,2]^2) -
#'   1/3*exp(-(xm[,1]+1)^2 - xm[,2]^2)
#' dat <- data.frame(xm, z)
#' # graph of original data
#' wireframe(z ~ Var1 + Var2, dat, drape = TRUE, colorkey = TRUE)
#'
#' xi <- seq(-3, 3, 0.25)
#' zi_l <- interp2(x, x, matrix(z, length(x)), xi, xi, 'linear')
#' dat_l <- data.frame(expand.grid(xi, xi), zi_l)
#' # graph of linearly interpolation
#' wireframe(zi_l ~ Var1 + Var2, dat_l, drape = TRUE, colorkey = TRUE)
#'
#' zi_s <- interp2(x, x, matrix(z, length(x)), xi, xi, 'spline')
#' dat_s <- data.frame(expand.grid(xi, xi), zi_s)
#' # graph of interpolation with spline
#' wireframe(zi_s ~ Var1 + Var2, dat_s, drape = TRUE, colorkey = TRUE)
#' @export
interp2 <- function(x, y, v, xi, yi, method) {
    .Call('rfda_interp2', PACKAGE = 'rfda', x, y, v, xi, yi, method)
}

#' Two-dimensional kernel linear local smoother
#'
#' Perform two-dimensional kernel linear local smoother for data \code{(x,y)} with weight \code{w} on \code{xout}.
#'
#' @param bandwidth A numeric vector with two values. The kernel smoothing parameters.
#' @param x A matrix, the variable of of x-axis and y-axis.
#' @param y A vector, the variable of of z-axis. \code{y[i]} is corresponding value of \code{x[i, ]}.
#' @param w A vector, the weight of data. \code{w[i]} is corresponding value of \code{x[i,]}.
#' @param count A vector, the number of observations at \code{x[i, ]}.
#' @param out1 A vector, the output grid of x-coordinate. It should be a sorted vecotr.
#' @param out2 A vector, the output grid of y-coordinate. It should be a sorted vecotr.
#' @param kernel A string. It could be 'gauss', 'gaussvar', 'epan' or 'quar'.
#' @return A smoothed covariance estimated by two-dimensional kernel local linear smoother.
#' @examples
#' data("regularExData", package = 'rfda')
#' sparsity <- checkSparsity(regularExData, "sampleID", "t")
#' bwCand <- bwCandChooser(regularExData, "sampleID", "t", sparsity, "gauss", 1)
#' w <- rep(1, nrow(regularExData))
#' bwOpt <- gcvLocPoly1d(bwCand, regularExData$t, regularExData$y, w, "gauss", 0, 1)
#' bwOpt <- adjGcvBw(bwOpt, sparsity, "gauss", 0)
#' xout <- sort(unique(regularExData$t))
#' meanFunc <- locPoly1d(bwOpt, regularExData$t, regularExData$y, w, xout, "gauss", 0, 1)
#' require(data.table)
#' require(pipeR)
#' setDT(regularExData, key = "t")
#' dataDT <- merge(regularExData, data.table(mf = meanFunc, t = xout, key = "t"), by = "t") %>>%
#'   `[`( , `:=`(y = y - mf, variable = "y")) %>>%
#'   setnames(c("t", "y", "sampleID"), c("timePnt", "value.demean", "subId"))
#' RawCov <- getRawCrCov(dataDT)
#'
#' xout2 <- seq(min(regularExData$t), max(regularExData$t), len = 30)
#' RawCovNoDiag <- RawCov[t1 != t2]
#' covFunc <- locLinear2d(c(1, 1), as.matrix(RawCovNoDiag[ , .(t1, t2)]), RawCovNoDiag$sse,
#'   RawCovNoDiag$weight, RawCovNoDiag$cnt, xout2, xout2, "gauss")
#' @export
locLinear2d <- function(bandwidth, x, y, w, count, out1, out2, kernel) {
    .Call('rfda_locLinear2d', PACKAGE = 'rfda', bandwidth, x, y, w, count, out1, out2, kernel)
}

#' Find the optimal bandwidth for two-dimensional kernel linear local smoother
#'
#' Find the optimal bandwidth used in \code{\link{locLinear2d}}.
#'
#' @param bwCand A numerical vector for the candidates of bandwidth.
#' @param x A matrix, the variable of of x-axis and y-axis.
#' @param y A vector, the variable of of z-axis. \code{y[i]} is corresponding value of \code{x[i, ]}.
#' @param w A vector, the weight of data. \code{w[i]} is corresponding value of \code{x[i,]}.
#' @param count A vector, the number of observations at \code{x[i, ]}.
#' @param kernel A string. It could be 'gauss', 'gaussvar', 'epan' or 'quar'.
#' @param bwNumGrid The number of support points of smoothing surface.
#'   A smaller \code{bwNumGrid} accelerate process at less accuracy.
#' @return A optimal bandwidth selected by minimizing gcv scores.
#' @examples
#' data("regularExData", package = 'rfda')
#' sparsity <- checkSparsity(regularExData, "sampleID", "t")
#' bwCand <- bwCandChooser(regularExData, "sampleID", "t", sparsity, "gauss", 1)
#' w <- rep(1, nrow(regularExData))
#' bwOpt <- gcvLocPoly1d(bwCand, regularExData$t, regularExData$y, w, "gauss", 0, 1)
#' bwOpt <- adjGcvBw(bwOpt, sparsity, "gauss", 0)
#' xout <- sort(unique(regularExData$t))
#' meanFunc <- locPoly1d(bwOpt, regularExData$t, regularExData$y, w, xout, "gauss", 0, 1)
#' require(data.table)
#' require(pipeR)
#' setDT(regularExData, key = "t")
#' dataDT <- merge(regularExData, data.table(mf = meanFunc, t = xout, key = "t"), by = "t") %>>%
#'   `[`( , `:=`(y = y - mf, variable = "y")) %>>%
#'   setnames(c("t", "y", "sampleID"), c("timePnt", "value.demean", "subId"))
#' RawCov <- getRawCrCov(dataDT)
#'
#' RawCovNoDiag <- RawCov[t1 != t2]
#' bwCand <- bwCandChooser2(RawCovNoDiag, sparsity, "gauss", 1)
#' bwOpt <- gcvLocLinear2d(bwCand, as.matrix(RawCovNoDiag[ , .(t1, t2)]), RawCovNoDiag$sse,
#'   RawCovNoDiag$weight, RawCovNoDiag$cnt, "gauss", 30)
#' bwOpt <- adjGcvBw(bwOpt, 2, "gauss", 0)
#' @export
gcvLocLinear2d <- function(bwCand, x, y, w, count, kernel, bwNumGrid = 30.0) {
    .Call('rfda_gcvLocLinear2d', PACKAGE = 'rfda', bwCand, x, y, w, count, kernel, bwNumGrid)
}

locLinearRotate2d_cpp <- function(bandwidth, x, y, w, count, outMat, kernel) {
    .Call('rfda_locLinearRotate2d_cpp', PACKAGE = 'rfda', bandwidth, x, y, w, count, outMat, kernel)
}

locPoly1d_cpp <- function(bandwidth, x, y, w, xout, kernel, drv, degree) {
    .Call('rfda_locPoly1d_cpp', PACKAGE = 'rfda', bandwidth, x, y, w, xout, kernel, drv, degree)
}

#' Find the optimal bandwidth for one-dimensional kernel local polynominal smoother
#'
#' Find the optimal bandwidth used in \code{\link{locPoly1d}}.
#'
#' @param bwCand A numerical vector for the candidates of bandwidth.
#' @param x A vector, the variable of of x-axis.
#' @param y A vector, the variable of of y-axis. \code{y[i]} is corresponding value of \code{x[i]}.
#' @param w A vector, the weight of data. \code{w[i]} is corresponding value of \code{x[i]}.
#' @param kernel A string. It could be 'gauss', 'gaussvar', 'epan' or 'quar'.
#' @param drv An integer, the order of derivative.
#' @param degree An integer, the degree of polynomial.
#' @return A optimal bandwidth selected by minimizing gcv scores.
#' @examples
#' data("regularExData", package = 'rfda')
#' bwCand <- bwCandChooser(regularExData, "sampleID", "t", 2, "gauss", 1)
#' w <- rep(1, nrow(regularExData))
#' bwOpt <- gcvLocPoly1d(bwCand, regularExData$t, regularExData$y, w, "gauss", 0, 1)
#' bwOpt <- adjGcvBw(bwOpt, 2, "gauss", 0)
#' @export
gcvLocPoly1d <- function(bwCand, x, y, w, kernel, drv, degree) {
    .Call('rfda_gcvLocPoly1d', PACKAGE = 'rfda', bwCand, x, y, w, kernel, drv, degree)
}

#' One-dimensional kernel local polynominal smoother of quantiles
#'
#' Perform one-dimensional kernel local polynominal smoother of quantiles corresponding to the
#' given probabilities for data \code{(x,y)} with weight \code{w} on \code{xout}.
#'
#' @param bandwidth A single numerical value. The kernel smoothing parameter.
#' @param probs A numeric vector with values between 0 and 1. The probabilities of quantiles.
#' @param x A vector, the variable of of x-axis.
#' @param y A vector, the variable of of y-axis. \code{y[i]} is corresponding value of \code{x[i]}.
#' @param w A vector, the weight of data. \code{w[i]} is corresponding value of \code{x[i]}.
#' @param xout A vector, vector of output time points. It should be a sorted vecotr.
#' @param kernel A string. It could be 'gauss', 'gaussvar', 'epan' or 'quar'.
#' @param drv An integer, the order of derivative.
#' @param degree An integer, the degree of polynomial.
#' @return A estimated value on \code{xout} by one-dimensional kernel local polynominal smoother of quantiles
#' corresponding to the given probabilities.
#' @references
#' \enumerate{
#'   \item https://www.r-statistics.com/2010/04/quantile-loess-combining-a-moving-quantile-window-with-loess-r-function
#' }
#' @examples
#' N <- 100
#' x <- runif(N, 0, 10)
#' y <- rnorm(N)
#' xout <- sort(runif(200, 0, 10))
#' est <- locPoly1d(1.2, x, y, rep(1, N), xout, 'gauss', 0, 1)
#' require(pipeR)
#' require(data.table)
#' est_quant <- locQuantPoly1d(1.2, c(0.25, 0.5, 0.75), x, y, rep(1, N), xout, 'gauss', 0, 1) %>>%
#'   data.table %>>% setnames(c("Q25", "Q50", "Q75"))
#' linesDF <- est_quant[ , `:=`(x = xout, loess = est)] %>>% melt.data.table("x", value.name = "y")
#' require(ggplot2)
#' ggplot(data.frame(x,y), aes(x, y)) + geom_point() +
#'   geom_line(aes(x, y, colour = variable), data = linesDF) +
#'   labs(colour = "Type")
#' @export
locQuantPoly1d <- function(bandwidth, probs, x, y, w, xout, kernel, drv, degree) {
    .Call('rfda_locQuantPoly1d', PACKAGE = 'rfda', bandwidth, probs, x, y, w, xout, kernel, drv, degree)
}

#' trapz: trapezoidal rule to approximate the integral values
#'
#' Returns approximation of integral.
#'
#' @param m A numeric matrix to be divided into list of matrices.
#' @param margin The margin of the matrix to split.
#' @param f A integer vector to split the matrix.
#' @return A list of matrices.
#' @examples
#' x <- matrix(rnorm(30), 6, 8)
#' splitMat(x, 1, rep(1:3, each = 2))
#' splitMat(x, 2, rep(1:4, each = 2))
#' @export
splitMat <- function(m, margin, f) {
    .Call('rfda_splitMat', PACKAGE = 'rfda', m, margin, f)
}

#' unique rows
#'
#' Return the unique rows with quick sort algorithm.
#'
#' @param x A matrix.
#' @return A matrix with unique rows.
#' @examples
#' unique_rows(matrix(c(1,1,2,2,3,3,1,1,1,1,4,5),, 2))
#' #      [,1] [,2]
#' # [,1]    1    1
#' # [,2]    2    1
#' # [,3]    3    4
#' # [,4]    3    5
#' @export
unique_rows <- function(x) {
    .Call('rfda_unique_rows', PACKAGE = 'rfda', x)
}

